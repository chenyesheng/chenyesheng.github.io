<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu搭建Jenkins+Android自动化打包]]></title>
    <url>%2F2018%2F11%2F23%2FUbuntu%E6%90%AD%E5%BB%BAJenkins-Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[*本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 本文主要介绍如何在Ubuntu搭建Jenkins实现Android项目的自动化打包，一般部署在我们的服务器，这里我通过虚拟机安装Ubuntu来进行演示 环境配置下载并配置java环境 通过java官网下载对应jdk版本 打开终端，输入以下命令行进行解压 1tar -zxvf jdk-8u181-linux-x64.tar.gz 将解压后的文件夹移动到/opt目录下 1sudo mv jdk1.8.0_181 /opt/ 修改环境变量 1sudo vi ~/.bashrc 在末尾添加如下配置：12345#set Java environmentexport JAVA_HOME=/opt/jdk1.8.0_181export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 保存退出，使用source命令使其生效 1source ~/.bashrc 验证java环境是否配置成功 1java -vsersion Git安装1sudo apt-get install git 安装配置nginx为了使得外部能下载相关资源，安装并配置本地目录映射123sudo apt-get install nginxsudo service nginx startsudo vi /etc/nginx/nginx.conf 简单修改配置文件，添加如下内容1234567891011server &#123; listen 81; server_name 192.168.80.140; client_max_body_size 4G; root /home/cc/pkg_bak; location / &#123; autoindex on; autoindex_exact_size on; autoindex_localtime on; &#125;&#125; 使配置生效1sudo service nginx reload Jenkins安装可以根据Jenkins官网文档进行安装1234wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -sudo sh -c &apos;echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list&apos;sudo apt-get updatesudo apt-get install jenkins 修改Jenkins配置1sudo vi /etc/default/jenkins 修改端口号12# 默认是8080端口HTTP_PORT=8081 启动Jenkins1sudo service jenkins start 启动完成，通过浏览器访问 http://192.168.80.140:8081 即可看到启动界面 根据提示通过查看 /var/lib/jenkins/secrets/initialAdminPassword 获取到密码即可 然后根据提示安装需要的插件，创建用户，完成后出现下面的界面，Jenkins 搭建完成 配置Android项目编译环境安装常用插件路径：系统管理-插件管理-可选插件，在搜索框输入你需要安装的插件进行安装即可 常用插件有以下： Git plugin Git Parameter GitLab Plugin Gradle Plugin Android Emulator Plugin Android Lint Plugin description setter plugin Checkstyle Plug-in FindBugs Plug-in PMD Plug-in SSH Agent Role-based Authorization Strategy OWASP Markup Formatter Plugin 配置Git路径：系统管理-全局工具配置-Git 因为Ubuntu已经安装了Git，所以默认配置即可 配置JDK路径：系统管理-全局工具配置-JDK 下载需要一个Oracle的帐号，添加完账户就可以了 配置Gradle路径：系统管理-全局工具配置-Gradle 配置Android SDK路径：系统管理-系统设置-Android 填写SDK的存放路径，同时勾选自动下载，警告可以忽略 这个时候有一个问题需要注意，必须在sdk的目录下 添加license文件，去你本地的sdk下拷贝一份进去 新建工程 填写General一般会勾选丢弃旧的构建，防止服务器累计过多次的编译 填写源码管理使用Git来拉取代码 构建配置 上内容述执行的是： 重置，清空项目内容 将存在服务器的密钥信息、sdk目录等信息（local.properties），拷贝到项目中 使用工程下的gradlew来构建项目，保持gradle版本与本地一致，Tasks中输入项目要编译的任务 因为我的密钥读取是放到 local.properties 文件中的，所以可以做到服务器管控打包密钥，local.properties 内容如下12345KEY_STORE=密钥路径KEY_STORE_PASSWORD=密码KEY_ALIAS=密钥别名KEY_ALIAS_PASSWORD=密码sdk.dir=sdk路径 构建后配置需要收集相应的apk和mapping文件 最后点击保存，通过简单配置，到此已经可以实现项目的构建了 更多定制化配置通过Git Parameter插件实现分支选择 集成360加固从360官方下载相关文件，拷贝到/home/cc/backup/360jiagu目录，使用命令行的方式进行加固，详细可以查看官方说明文档，这里采用编写脚本文件实现自动加固，文件内容如下： 脚本jiagu_360.sh存放路径/home/cc/backup/360jiagu/jiagu1234567891011121314151617181920212223242526272829#!/bin/bashBASE_JAR=/home/cc/backup/360jiagu/jiagu/jiagu.jarJIA_GU_NAME=账号JIA_GU_PSD=密码echo &quot;------ jiagu running! ------&quot;java -jar $&#123;BASE_JAR&#125; -versionjava -jar $&#123;BASE_JAR&#125; -login $&#123;JIA_GU_NAME&#125; $&#123;JIA_GU_PSD&#125;LOCAL_PATH=$1echo &quot;local.properties:$&#123;LOCAL_PATH&#125;&quot;KEY_STORE=`cat $&#123;LOCAL_PATH&#125; |grep KEY_STORE= | awk -F= &apos;&#123;print $2&#125;&apos;`KEY_STORE_PASSWORD=`cat $&#123;LOCAL_PATH&#125; |grep KEY_STORE_PASSWORD= | awk -F= &apos;&#123;print $2&#125;&apos;`KEY_ALIAS=`cat $&#123;LOCAL_PATH&#125; |grep KEY_ALIAS= | awk -F= &apos;&#123;print $2&#125;&apos;`KEY_ALIAS_PASSWORD=`cat $&#123;LOCAL_PATH&#125; |grep KEY_ALIAS_PASSWORD= | awk -F= &apos;&#123;print $2&#125;&apos;`java -jar $&#123;BASE_JAR&#125; -importsign $&#123;KEY_STORE&#125; $&#123;KEY_STORE_PASSWORD&#125; $&#123;KEY_ALIAS&#125; $&#123;KEY_ALIAS_PASSWORD&#125;java -jar $&#123;BASE_JAR&#125; -showsignBuildApkLine=$2Build_JiaGu_Dir=$3echo &quot;BuildApkLine:$&#123;BuildApkLine&#125;, Build_JiaGu_Dir=$&#123;Build_JiaGu_Dir&#125;&quot;java -jar $&#123;BASE_JAR&#125; -jiagu $BuildApkLine $Build_JiaGu_Dir -autosign echo &quot;------ jiagu finished! ------&quot; 生成二维码，在构建历史展示更多信息 安装description setter plugin插件 在Ubuntu上安装qrencode, 用于生成二维码图片 1sudo apt-get install qrencode 修改构建任务，在项目编译完加固完成后执行下面命令 123456789101112131415161718192021222324252627282930313233343536373839BuildApkLine=`find ./jiagu -name *_jiagu_sign.apk`# 备份到文件服务器PkgBakDir=&quot;/home/cc/pkg_bak/$&#123;JOB_NAME&#125;&quot;if [ ! -d &quot;$PkgBakDir&quot; ]; thenmkdir $PkgBakDirfiBuildDir=&quot;$PkgBakDir/$&#123;BUILD_NUMBER&#125;&quot;if [ ! -d &quot;$BuildDir&quot; ]; thenmkdir $BuildDirfiApkName=$&#123;BuildApkLine##*/&#125;LastestApkName=&quot;dev_lastest.apk&quot;cp $BuildApkLine $BuildDirif [ -f &quot;$PkgBakDir/$LastestApkName&quot; ]; thenrm $PkgBakDir/$LastestApkNamefiln -s &quot;$BuildDir/$ApkName&quot; &quot;$PkgBakDir/$LastestApkName&quot;QrcodeValue=&quot;http://192.168.80.140:81/$&#123;JOB_NAME&#125;/$&#123;BUILD_NUMBER&#125;/$ApkName&quot;echo &quot;QrcodeValue is $QrcodeValue&quot; LastQrcodeValue=&quot;http://192.168.80.140:81/$&#123;JOB_NAME&#125;/$LastestApkName&quot;echo &quot;LastQrcodeValue is $LastQrcodeValue&quot; # 将debug apk的下载地址 生成二维码，以供下载qrencode -o qrcode.png $QrcodeValue# 将debug apk的下载地址 生成二维码，以供下载qrencode -o last_qrcode.png $LastQrcodeValue# 输出debug apk的下载地址，机械号，版本名称echo &quot;BuildUrl: $QrcodeValue,$VersionCode,$VersionName,$dev_branch,$Tasks&quot; 构建后操作，添加Set build description 这里解释一下这两个参数： Regular expression：BuildUrl: (.),(.),(.),(.)通过正则匹配获取到上面BuildUrl的4个参数，分别为apk地址、机械号、版本名称、分支名称 Description，描述，这里以html格式输出其中 \1，\2..分别对应上面匹配的4个参数 完成后的结果如下： 集成fir自动上传打包完成后实现自动上传到fir，可参考 fir官方文档，这里我们通过编写Python脚本实现自动上传功能，脚本代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/python# -*- coding: UTF-8 -*-import requestsimport jsonimport sys# 需要的参数REQUEST_PARAM = &#123; &apos;api_token&apos;: &apos;这里填写自己的token信息&apos;, &apos;type&apos;: &apos;android&apos;, &apos;applicationId&apos;: &apos;com.xxx.xxx&apos;, &apos;appName&apos;: &apos;应用名称&apos;, &apos;versionName&apos;: &apos;1.0.1.0&apos;, &apos;versionCode&apos;: &apos;10&apos;, &apos;changelog_path&apos;: &apos;changelog文件地址&apos;, &apos;apk_path&apos;: &apos;apk地址&apos;&#125;# 初始化传入的参数def init_param(): print(&apos;获取到传递过来的参数：&apos;, str(sys.argv)) REQUEST_PARAM[&apos;type&apos;] = sys.argv[1] REQUEST_PARAM[&apos;applicationId&apos;] = sys.argv[2] REQUEST_PARAM[&apos;appName&apos;] = sys.argv[3] REQUEST_PARAM[&apos;versionName&apos;] = sys.argv[4] REQUEST_PARAM[&apos;versionCode&apos;] = sys.argv[5] REQUEST_PARAM[&apos;changelog_path&apos;] = sys.argv[6] REQUEST_PARAM[&apos;apk_path&apos;] = sys.argv[7]# 获取上传凭证def get_cert(): print(&apos;发起获取上传凭证请求&apos;) param = &#123;&apos;type&apos;: REQUEST_PARAM[&apos;type&apos;], &apos;bundle_id&apos;: REQUEST_PARAM[&apos;applicationId&apos;], &apos;api_token&apos;: REQUEST_PARAM[&apos;api_token&apos;]&#125; print(&apos;获取上传凭证请求参数：&apos;, param) req = requests.post(url=&apos;http://api.fir.im/apps&apos;, data=param) cert_response = req.content print(&apos;获取上传凭证响应：&apos;, str(cert_response)) return cert_response# 上传到firdef upload_fir(binary, apk_path): binary_key = binary[&apos;key&apos;] binary_token = binary[&apos;token&apos;] binary_upload_url = binary[&apos;upload_url&apos;] print(&apos;开始上传Apk&apos;) changelog_str = open(REQUEST_PARAM[&apos;changelog_path&apos;]).read() file = &#123;&apos;file&apos;: open(apk_path, &apos;rb&apos;)&#125; param = &#123; &quot;key&quot;: binary_key, &quot;token&quot;: binary_token, &quot;x:name&quot;: REQUEST_PARAM[&apos;appName&apos;], &apos;x:version&apos;: REQUEST_PARAM[&apos;versionName&apos;], &apos;x:build&apos;: REQUEST_PARAM[&apos;versionCode&apos;], &quot;x:changelog&quot;: changelog_str &#125; req = requests.post(binary_upload_url, files=file, data=param) print(&apos;上传结果：&apos;, req.content)if __name__ == &apos;__main__&apos;: init_param() response = get_cert() # 得到获取上传凭证回调信息 cert_json = json.loads(response) cert_binary = cert_json[&apos;cert&apos;][&apos;binary&apos;] # 上传fir upload_fir(cert_binary, REQUEST_PARAM[&apos;apk_path&apos;]) 脚本代码注释也比较详细，不再展开说明，最后通过在上面加固完成后的shell脚本后面追加以下内容来实现自动上传 12345678910# 编写日志内容ChangeLog=changelog.txtecho &quot;Uploaded by fir cli&quot; &gt;&gt; $ChangeLogecho &quot;构建编号：$&#123;BUILD_NUMBER&#125;&quot; &gt;&gt; $ChangeLogecho &quot;修改记录：&quot; &gt;&gt; $ChangeLogecho &quot;$&#123;SCM_CHANGELOG&#125;&quot; &gt;&gt; $ChangeLogcat $ChangeLogpython /home/cc/backup/fir/uploadFir.py android $ApplicationId $AppName $VersionCode $VersionName $ChangeLog $BuildApkLine 常见问题Jenkins启动可能出现的问题1Job for jenkins.service failed because the control process exited with error code. See “systemctl status jenkins.service” and “journalctl -xe” for details. 根据提示输入sudo systemctl status jenkins.service123456789101112● jenkins.service - LSB: Start Jenkins at boot time Loaded: loaded (/etc/init.d/jenkins; generated) Active: failed (Result: exit-code) since Thu 2018-10-18 11:19:37 CST; 21s ago Docs: man:systemd-sysv-generator(8) Process: 3896 ExecStart=/etc/init.d/jenkins start (code=exited, status=1/FAILURE)10月 18 11:19:37 cc-virtual-machine systemd[1]: Starting LSB: Start Jenkins at boot time...10月 18 11:19:37 cc-virtual-machine jenkins[3896]: ERROR: No Java executable found in current PATH: /bin:/usr/bin:10月 18 11:19:37 cc-virtual-machine jenkins[3896]: If you actually have java installed on the system make sure the10月 18 11:19:37 cc-virtual-machine systemd[1]: jenkins.service: Control process exited, code=exited status=110月 18 11:19:37 cc-virtual-machine systemd[1]: jenkins.service: Failed with result &apos;exit-code&apos;.10月 18 11:19:37 cc-virtual-machine systemd[1]: Failed to start LSB: Start Jenkins at boot time. 从错误日志可以看出找不到java路径，解决方法：创建一条软链接1sudo ln -s /opt/jdk1.8.0_191/bin/java /usr/bin/java Jenkins权限问题Jenkins在执行shell脚本的时候可能出现权限问题，我们可以把jenkins账户加入到root组 将jenkins账户加入到root组 1sudo gpasswd -a root jenkins 修改 /etc/default/jenkins 内容 123# user and group to be invoked as (default to jenkins)JENKINS_USER=rootJENKINS_GROUP=root 重启jenkins 1sudo service jenkins restart 查看是否已经加入到root组 1cat /etc/group |grep jenkins 1jenkins:x:127:root 文件权限问题错误信息12/home/cc/backup/360jiagu/jiagu/jiagu_360.sh ./local.properties app/build/bakApk/resguard/ry_taxi_passenger20_1.0.2.0.apk ./jiagu/tmp/jenkins9129980792461988922.sh: 20: /tmp/jenkins9129980792461988922.sh: /home/cc/backup/360jiagu/jiagu/jiagu_360.sh: Permission denied 修改该文件权限即可1chmod 777 /home/cc/backup/360jiagu/jiagu/jiagu_360.sh]]></content>
      <categories>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign（五），TabLayout使用以及如何避坑]]></title>
    <url>%2F2018%2F11%2F23%2FMaterialDesign%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%8CTabLayout%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%9D%91%2F</url>
    <content type="text"><![CDATA[什么是 TabLayout TabLayout provides a horizontal layout to display tabs. 官方介绍，TabLayout 是一个横向标签显示的布局，效果就是现在很多新闻客户端的那种顶部标签展示效果，并支持指示器、 ViewPager 联动 简单使用按照惯例，我们先看一下效果图： 从效果图来看，这是采用 TabLayout + ViewPager 滑动切换和点击标签切换的一个效果。TabLayout 支持横向滚动多标签设置，还可以支持指示器，支持与 ViewPager 进行联动。下面看看具体实现 引入 com.android.support:designTabLayout 是属于 com.android.support:design 包的控件，所以需要依赖该包 1compile &apos;com.android.support:design:26.1.0&apos; xml 文件创建 1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tab_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:tabBackground=&quot;@color/colorPrimary&quot; app:tabIndicatorColor=&quot;#ffffff&quot; app:tabIndicatorHeight=&quot;3dp&quot; app:tabMode=&quot;scrollable&quot; app:tabPadding=&quot;2dp&quot; app:tabSelectedTextColor=&quot;#ffffff&quot; app:tabTextAppearance=&quot;@style/TabTextStyle&quot; app:tabTextColor=&quot;#333333&quot;/&gt; &lt;android.support.v4.view.ViewPager android:id=&quot;@+id/view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;&lt;/LinearLayout&gt; 从 xml 布局文件看，根布局为一个垂直的线性布局，包含 TabLayout 和 ViewPager。重点看一下 TabLayout 的几个常用属性值 app:tabBackground 标签布局的背景色 app:tabIndicatorColor 指示器的颜色 app:tabIndicatorHeight 指示器的高度（如果不需要指示器可以设置为0dp） app:tabMode 显示模式：默认 fixed（固定），scrollable（可横向滚动） app:tabPadding 标签内边距 app:tabSelectedTextColor 标签选中的文本颜色 app:tabTextAppearance 标签文本样式 app:tabTextColor 标签未选中的文本颜色 tab_custom_view.xml1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot; android:padding=&quot;5dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_tab_icon&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/tab_iv_selector&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_tab_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;2dp&quot; android:text=&quot;tab&quot; android:textColor=&quot;@color/tab_tv_selector&quot;/&gt;&lt;/LinearLayout&gt; tab_iv_selector.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/ic_add_black_24dp&quot; android:state_selected=&quot;false&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_add_white_24dp&quot; android:state_selected=&quot;true&quot;/&gt;&lt;/selector&gt; tab_tv_selector.xml12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:color=&quot;@android:color/black&quot; android:state_selected=&quot;false&quot;/&gt; &lt;item android:color=&quot;@android:color/white&quot; android:state_selected=&quot;true&quot;/&gt;&lt;/selector&gt; 以上是一个简单的自定义标签布局文件，可以看到 ImageView 的 src 和 TextView 的 textColor 属性值都使用了 selector，这样写的话就不需要再在代码监听选中的 Tab 去改变状态了，非常方便。该 xml 会在下面的代码中应用 Activity 中获取并设置相关属性值，以及事件监听 arrays.xml12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;string-array name=&quot;tab&quot;&gt; &lt;item&gt;推荐&lt;/item&gt; &lt;item&gt;视频&lt;/item&gt; &lt;item&gt;热点&lt;/item&gt; &lt;item&gt;社会&lt;/item&gt; &lt;item&gt;娱乐&lt;/item&gt; &lt;item&gt;科技&lt;/item&gt; &lt;item&gt;汽车&lt;/item&gt; &lt;item&gt;体育&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; TabLayoutActivity.java123456789101112131415161718192021222324252627282930313233@BindView(R.id.tab_layout)TabLayout mTabLayout;@BindView(R.id.view_pager)ViewPager mViewPager;private ArrayList&lt;MyFragment&gt; mFragments = new ArrayList&lt;&gt;();// 获取标签数组String[] tabName = getResources().getStringArray(R.array.tab);for (String s : tabName) &#123; MyFragment fragment = new MyFragment(); Bundle bundle = new Bundle(); bundle.putString(MyFragment.TAB, s); fragment.setArguments(bundle); mFragments.add(fragment);&#125;MyTabAdapter adapter = new MyTabAdapter(getSupportFragmentManager(), mFragments, tabName);mViewPager.setAdapter(adapter);// 关联 viewPagermTabLayout.setupWithViewPager(mViewPager);// FIXME 与 viewPager 关联后会为我们添加标题，所以可以通过 getTabAt 获取到标题for (int i = 0; i &lt; tabName.length; i++) &#123; TabLayout.Tab tab = mTabLayout.getTabAt(i); if (null != tab) &#123; tab.setCustomView(R.layout.tab_custom_view); if (null != tab.getCustomView()) &#123; ImageView imageView = tab.getCustomView().findViewById(R.id.iv_tab_icon); TextView textView = tab.getCustomView().findViewById(R.id.tv_tab_text); textView.setText(tabName[i]); &#125; &#125;&#125; MyFragment.java12345678910111213public class MyFragment extends Fragment &#123; public static final String TAB = &quot;TAB&quot;; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) &#123; String text = getArguments().getString(TAB); TextView textView = new TextView(getContext()); textView.setGravity(Gravity.CENTER); textView.setText(text); return textView; &#125;&#125; MyTabAdapter.java1234567891011121314151617181920212223242526272829303132public class MyTabAdapter extends FragmentStatePagerAdapter &#123; private ArrayList&lt;MyFragment&gt; mFragments; private String[] mTabName; public MyTabAdapter(FragmentManager fm, ArrayList&lt;MyFragment&gt; fragments, String[] tabName) &#123; super(fm); mFragments = fragments; mTabName = tabName; &#125; @Override public Fragment getItem(int position) &#123; return mFragments.get(position); &#125; @Override public int getCount() &#123; return mFragments.size(); &#125;// /**// * FIXME 调用 setupWithViewPager 方法后会为我们设置与 getCount 等量的空白标题，如果标题只有文字可以在此进行设置// *// * @param position// * @return// */// @Override// public CharSequence getPageTitle(int position) &#123;// return mTabName[position];// &#125;&#125; 从代码可以看出，先是获取到标签数组，创建 MyFragment 并将标签传入；创建 MyTabAdapter 并设置给 ViewPage。前门这几步都是 ViewPager 使用的正常操作。调用 TabLayout 的 setupWithViewPager() 传入 ViewPager 与之进行关联，关联之后 TabLayout 会根据 MyTabAdapter 的 getCount 方法生成对应数量的 Tab，最后我们通过 getTabAt 方法获取到对应的 Tab，并将 Tab 设置为我们的自定义视图。到这里已经实现了效果图所展示的效果 PS：虽然 TabLayout 已经为我们提供了默认标签的布局，可以设置图标和文字，同时也支持我们的自定义视图作为标签。但是为了应对需求的多变，我们最好还是使用自定义的视图作为标签布局 如何避坑调用 setupWithViewPager() 后 Tab 的视图不显示这里贴一下我第一次写的代码12345678910111213141516171819202122232425String[] tabName = getResources().getStringArray(R.array.tab);// 给 TabLayout 添加新 Tabfor (int i = 0; i &lt; tabName.length; i++) &#123; TabLayout.Tab tab = mTabLayout.newTab(); // 使用自定义tab视图 tab.setCustomView(R.layout.tab_custom_view); if (null != tab.getCustomView()) &#123; ImageView imageView = tab.getCustomView().findViewById(R.id.iv_tab_icon); TextView textView = tab.getCustomView().findViewById(R.id.tv_tab_text); textView.setText(tabName[i]); &#125; mTabLayout.addTab(tab);&#125;for (String s : tabName) &#123; MyFragment fragment = new MyFragment(); Bundle bundle = new Bundle(); bundle.putString(MyFragment.TAB, s); fragment.setArguments(bundle); mFragments.add(fragment);&#125;MyTabAdapter adapter = new MyTabAdapter(getSupportFragmentManager(), mFragments, tabName);mViewPager.setAdapter(adapter);// 关联 viewPagermTabLayout.setupWithViewPager(mViewPager); 看一下上面的代码，先是为 TabLayout 添加自定义布局的 Tab，然后再设置 ViewPager，并调用 setupWithViewPager() 进行关联。看起来没有什么问题。运行之后，发现 Tab 都是空白的。因为一开始没有关联 ViewPager 的时候，我运行是正常的，所以问题肯定是出在 setupWithViewPager() 这个方法。下面我们看一下这个方法的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void setupWithViewPager(@Nullable ViewPager viewPager) &#123; setupWithViewPager(viewPager, true);&#125;public void setupWithViewPager(@Nullable final ViewPager viewPager, boolean autoRefresh) &#123; setupWithViewPager(viewPager, autoRefresh, false);&#125;private void setupWithViewPager(@Nullable final ViewPager viewPager, boolean autoRefresh, boolean implicitSetup) &#123; // ...省略了一些监听器设置 if (viewPager != null) &#123; mViewPager = viewPager; // Add our custom OnPageChangeListener to the ViewPager if (mPageChangeListener == null) &#123; mPageChangeListener = new TabLayoutOnPageChangeListener(this); &#125; mPageChangeListener.reset(); viewPager.addOnPageChangeListener(mPageChangeListener); // Now we&apos;ll add a tab selected listener to set ViewPager&apos;s current item mCurrentVpSelectedListener = new ViewPagerOnTabSelectedListener(viewPager); addOnTabSelectedListener(mCurrentVpSelectedListener); final PagerAdapter adapter = viewPager.getAdapter(); if (adapter != null) &#123; // Now we&apos;ll populate ourselves from the pager adapter, adding an observer if // autoRefresh is enabled1. setPagerAdapter(adapter, autoRefresh); &#125; // Add a listener so that we&apos;re notified of any adapter changes if (mAdapterChangeListener == null) &#123; mAdapterChangeListener = new AdapterChangeListener(); &#125; mAdapterChangeListener.setAutoRefresh(autoRefresh); viewPager.addOnAdapterChangeListener(mAdapterChangeListener); // Now update the scroll position to match the ViewPager&apos;s current item setScrollPosition(viewPager.getCurrentItem(), 0f, true); &#125; else &#123; // We&apos;ve been given a null ViewPager so we need to clear out the internal state, // listeners and observers mViewPager = null; setPagerAdapter(null, false); &#125; mSetupViewPagerImplicitly = implicitSetup;&#125; 从源码可以看出，最后都是调用到 setupWithViewPager(@Nullable final ViewPager viewPager, boolean autoRefresh, boolean implicitSetup) 方法，重点看 setPagerAdapter(adapter, autoRefresh); 方法，继续进入到该方法123456789101112131415161718192021222324252627282930313233343536373839void setPagerAdapter(@Nullable final PagerAdapter adapter, final boolean addObserver) &#123; if (mPagerAdapter != null &amp;&amp; mPagerAdapterObserver != null) &#123; // If we already have a PagerAdapter, unregister our observer mPagerAdapter.unregisterDataSetObserver(mPagerAdapterObserver); &#125; mPagerAdapter = adapter; if (addObserver &amp;&amp; adapter != null) &#123; // Register our observer on the new adapter if (mPagerAdapterObserver == null) &#123; mPagerAdapterObserver = new PagerAdapterObserver(); &#125; adapter.registerDataSetObserver(mPagerAdapterObserver); &#125; // Finally make sure we reflect the new adapter2. populateFromPagerAdapter();&#125;void populateFromPagerAdapter() &#123;3. removeAllTabs(); if (mPagerAdapter != null) &#123; final int adapterCount = mPagerAdapter.getCount(); for (int i = 0; i &lt; adapterCount; i++) &#123;4. addTab(newTab().setText(mPagerAdapter.getPageTitle(i)), false); &#125; // Make sure we reflect the currently set ViewPager item if (mViewPager != null &amp;&amp; adapterCount &gt; 0) &#123; final int curItem = mViewPager.getCurrentItem(); if (curItem != getSelectedTabPosition() &amp;&amp; curItem &lt; getTabCount()) &#123; selectTab(getTabAt(curItem)); &#125; &#125;![TabLayout.gif](http://upload-images.jianshu.io/upload_images/1131117-d9a80453a1363fbd.gif?imageMogr2/auto-orient/strip) &#125;&#125; 最后调用到了 populateFromPagerAdapter() 方法，到了这里基本找到问题了，populateFromPagerAdapter 第一行代码 removeAllTabs() 移除了所有的 Tab 后又根据 mPagerAdapter.getCount() 的数量添加新的 Tab，并为新的 Tab 设置了文本，文本内容则是通过 mPagerAdapter.getPageTitle(int) 获取。分析到处，我们的问题很容易就可以解决了。正确写法就是在简单使用的第三点所贴的代码 关键知识点总结 如果要使 Tab 可横向滑动，需在 TabLayout 的 app:tabMode 属性设置为 scrollable 如果不需要 Tab 的指示器的时候，有两种方法：方法一、设置 app:tabIndicatorColor=&quot;@android:color/transparent&quot;，方法二、设置 app:tabIndicatorHeight=&quot;0dp&quot; 系统默认的 Tab 支持可设置图片（上）和文字（下），如果需要可定制的 Tab 可以使用 setCustomView() 设置自定义视图 自定义 Tab 支持使用 selector，采用 selector 方式更方便的设置选中和未选中时的状态，而无需在代码进行状态切换 与 ViewPager 关联时，如果 Tab 只有本文，则可以重写 Adapter 的 getPageTitle() 方法即可 与 ViewPager 关联时，如果需要自定义 Tab，则通过调用 setupWithViewPager() 方法后再通过 TabLayout 的 getTabAt(int) 方法获取到对应的 Tab 进行相关设置即可 结语本文主要介绍了 TabLayout 的使用以及如何关联 ViewPager。该控件实际开发也非常实用，目前市场上的很多新闻类客户端等都有此效果。本文 demo 已上传到 github 以下是官方API地址（自备梯子） TabLayout API]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
        <tag>TabLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign（四），RecyclerView、SwipeRefreshLayout、CardView使用]]></title>
    <url>%2F2018%2F11%2F23%2FMaterialDesign%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%8CRecyclerView%E3%80%81SwipeRefreshLayout%E3%80%81CardView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是 RecyclerViewRecyclerView 到现在为止可以说是人人皆知了，到目前 RecyclerView 已经完全替代了以前的 ListView、GridView等控件，可以说 RecyclerView 使用起来更加的灵活，高度解耦，高度可定制化，能实现的效果也是非常之多 什么是 SwipeRefreshLayoutSwipeRefreshLayout 是 Google 官方推出的一款下拉刷新组件。使用起来也是非常的方便 什么是 CardViewCardView 继承自 FrameLayout 类，是一种卡片视图，主要是以卡片形式显示内容，可实现圆角和阴影效果的一个控件。大多时候作为 RecyclerView 等列表控件的 item 进行使用 简单使用按照惯例，我们先看一下效果图： 从效果图来看，该效果是从上一篇 MaterialDesign（三），CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout使用 的基础上实现的，主要实现了 RecyclerView 提供的四种 LayoutManager，RecyclerView item 点击回调监听；SwipeRefreshLayout 下拉刷新操作；CardView 作为 item 的布局展示，下面看看具体实现 引入 com.android.support:cardview由于 RecyclerView 是 v7 包的控件，v7 包之前已经引入过了，在此仅需单独引入 CardView 对应包 1compile &apos;com.android.support:cardview-v7:26.1.0&apos; xml 文件创建activity 的 xml 布局 123456789101112// ...这里省略了 CoordinatorLayout 相关，完整代码请查看文末的 demo&lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/refresh_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; item 的 xml 布局12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;140dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; app:cardBackgroundColor=&quot;#ffffdd&quot; app:cardCornerRadius=&quot;5dp&quot; app:cardElevation=&quot;5dp&quot; app:contentPadding=&quot;10dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;ImageView android:id=&quot;@+id/iv_item&quot; android:layout_width=&quot;60dp&quot; android:layout_height=&quot;50dp&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/android_bg&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot;/&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; SwipeRefreshLayout 和 RecyclerView 的 xml 使用非常简单，不作过多说明，这里主要看 item 中的 CardView 控件，CardView 作为 item 的根布局，里面可以包含任意控件，重点关注一下 CardView 的几个属性 app:cardBackgroundColor 设置卡片布局的背景色 app:cardCornerRadius 设置卡片布局的圆角大小 app:cardElevation 设置卡片布局的阴影大小 app:contentPadding 设置卡片布局内容于边距的间隔 这里只列举几个比较常用的属性值设置，更多属性值可查看 API 文档，这些属性也支持在代码中进行设置 Activity 中获取并设置相关属性值，以及事件监听123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133@BindView(R.id.refresh_layout)SwipeRefreshLayout mRefreshLayout;@BindView(R.id.recycler_view)RecyclerView mRecyclerView;mToolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.action_vertical_layout: LinearLayoutManager verticalManager = new LinearLayoutManager(CoordinatorLayoutActivity.this, LinearLayoutManager.VERTICAL, false); mRecyclerView.setLayoutManager(verticalManager); break; case R.id.action_horizontal_layout: LinearLayoutManager horizontalManager = new LinearLayoutManager(CoordinatorLayoutActivity.this, LinearLayoutManager.HORIZONTAL, false); mRecyclerView.setLayoutManager(horizontalManager); break; case R.id.action_grid_layout: GridLayoutManager gridLayoutManager = new GridLayoutManager(CoordinatorLayoutActivity.this, 2); mRecyclerView.setLayoutManager(gridLayoutManager); break; case R.id.action_staggered_grid_layout: StaggeredGridLayoutManager staggeredGridLayoutManager = new StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL); // 空隙不作处理，防止item乱跳 staggeredGridLayoutManager.setGapStrategy(StaggeredGridLayoutManager.GAP_HANDLING_NONE); mRecyclerView.setLayoutManager(staggeredGridLayoutManager); break; &#125; return false; &#125;&#125;);// 设置进度条颜色，支持多颜色，第一个颜色值会在手势下拉时作为显示mRefreshLayout.setColorSchemeColors(Color.RED, Color.GREEN, Color.BLUE);mRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; // 延时2秒执行，模拟网络访问 new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; // 结束刷新 mRefreshLayout.setRefreshing(false); Toast.makeText(CoordinatorLayoutActivity.this, &quot;刷新完成&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;, 2000); &#125;&#125;);LinearLayoutManager linearLayoutManager = new LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false);mRecyclerView.setLayoutManager(linearLayoutManager);final ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 20; i++) &#123; list.add(i + &quot;&quot;);&#125;MyRecyclerViewAdapter adapter = new MyRecyclerViewAdapter(list);mRecyclerView.setAdapter(adapter);adapter.setOnItemClickListener(new MyRecyclerViewAdapter.IOnItemClickListener() &#123; @Override public void onItemClick(View view, int position) &#123; Toast.makeText(CoordinatorLayoutActivity.this, &quot;点击了：&quot; + list.get(position), Toast.LENGTH_SHORT).show(); &#125;&#125;); public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyRecyclerViewAdapter.MyViewHolder&gt; &#123; private ArrayList&lt;String&gt; mList; private IOnItemClickListener mOnItemClickListener; public MyRecyclerViewAdapter(ArrayList&lt;String&gt; list) &#123; this.mList = list; &#125; @Override public MyRecyclerViewAdapter.MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.item_recycler_view_layout, parent, false); return new MyViewHolder(view); &#125; @Override public void onBindViewHolder(final MyViewHolder holder, int position) &#123; holder.mTextView.setText(mList.get(position)); // 动态改变 ImageView 高度 ViewGroup.LayoutParams params = holder.mImageView.getLayoutParams(); params.height = (int) (100 + Math.random() * 200); holder.mImageView.setLayoutParams(params); // 设置item点击监听 if (null != mOnItemClickListener) &#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mOnItemClickListener.onItemClick(view, holder.getLayoutPosition()); &#125; &#125;); &#125; &#125; @Override public int getItemCount() &#123; return mList.size(); &#125; /** * 设置item监听器 * * @param onItemClickListener */ public void setOnItemClickListener(IOnItemClickListener onItemClickListener) &#123; mOnItemClickListener = onItemClickListener; &#125; public class MyViewHolder extends RecyclerView.ViewHolder &#123; public ImageView mImageView; public TextView mTextView; public MyViewHolder(View itemView) &#123; super(itemView); mImageView = itemView.findViewById(R.id.iv_item); mTextView = itemView.findViewById(R.id.tv_item); &#125; &#125; /** * item 回调监听 * 由于 RecyclerView 没有提供item的点击监听，所以要自己提供接口进行回调 */ public interface IOnItemClickListener &#123; void onItemClick(View view, int position); &#125;&#125; 首先看 SwipeRefreshLayout 设置了下拉时进度条的颜色值，并设置了刷新时的事件监听，在里面我们延时2秒（模拟网络访问）执行了 mRefreshLayout.setRefreshing(false) 方法来结束刷新，必须调用此方法后进度条才会消失 重点看一下 RecyclerView 的使用。首先要为 RecyclerView 设置 LayoutManager，然后和 ListView 用法类似，也是需呀设置 Adapter。比较麻烦的是如果你需要设置 item 的分割线，需要调用 mRecyclerView.addItemDecoration() 方法进行设置，该方法的参数是 RecyclerView.ItemDecoration，需要我们自己去实现，如果只是简单的分割线，我一般都会在 item 的 xml 布局里进行添加。还有 RecyclerView 并没有为我们提供 item 点击事件的设置，所以我们要在 Adapter 里提供一个接口回调，再进行设置，其他事件类似。 adapter 的代码和 ListView 的 adapter 用法区别不大，在 onBindViewHolder 方法里，我们动态改变 ImageView 的高度主要是为了在为 RecyclerView 设置 StaggeredGridLayoutManager（瀑布流） 的时候能较明显的看出其效果 最后在 Toolbar 菜单项点击的时候对 RecyclerView 的 LayoutManager 进行切换，展示系统提供的几种布局 LinearLayoutManager 线性管理器，支持横向、纵向 GridLayoutManager 网格布局管理器 StaggeredGridLayoutManager 瀑布流式布局管理器 这里我们只是简单的介绍一下 RecyclerView，如果想要更详细的学习，可以参考鸿洋大神的文章 Android RecyclerView 使用完全解析 体验艺术般的控件 结语本文主要简单介绍了 RecyclerView + SwipeRefreshLayout + CardView 的使用。RecyclerView 在实际开发中应用非常广泛，只有你想不到，没有他做不到的时候，所以 RecyclerView 还是非常值得学习使用的。本文 demo 已上传到 github 下面是几个控件的官方 API 地址（自备梯子） RecyclerView API SwipeRefreshLayout API CardView API]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
        <tag>RecyclerView</tag>
        <tag>SwipeRefreshLayout</tag>
        <tag>CardView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign（三），CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout使用]]></title>
    <url>%2F2018%2F11%2F23%2FMaterialDesign%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%8CCoordinatorLayout%E3%80%81AppBarLayout%E3%80%81CollapsingToolbarLayout%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是 CoordinatorLayout CoordinatorLayout is a super-powered FrameLayout.CoordinatorLayout is intended for two primary use cases:1.As a top-level application decor or chrome layout2.As a container for a specific interaction with one or more child views 根据官方的介绍，CoordinatorLayout 继承自 ViewGroup，主要有以下两个用途 作为一个应用顶层的装饰布局，也就是一个Activity Layout 的最外一层布局 作为一个或多个有特定响应动作的容器，协调(Coordinate)其他组件, 实现联动 什么是 AppBarLayout AppBarLayout is a vertical LinearLayout which implements many of the features of material designs app bar concept, namely scrolling gestures. Children should provide their desired scrolling behavior through setScrollFlags(int) and the associated layout xml attribute: app:layout_scrollFlags. This view depends heavily on being used as a direct child within a CoordinatorLayout. If you use AppBarLayout within a different ViewGroup, most of it’s functionality will not work. 根据官方的介绍 AppBarLayout 继承自 LinearLayout，子控件默认为竖直方向，可以用它实现 Material Design 的 Toolbar，支持滑动手势 它的子控件可以通过在代码里调用 setScrollFlags(int) 或者在XML里 app:layout_scrollFlags 来设置它的滑动手势 根布局必须使用 CoordinatorLayout，否则很多功能无法正常使用 什么是 CollapsingToolbarLayout CollapsingToolbarLayout is a wrapper for Toolbar which implements a collapsing app bar. It is designed to be used as a direct child of a AppBarLayout. 根据官方的介绍 CollapsingToolbarLayout 是一个折叠的 Toolbar 布局，作为 AppBarLayout 的直接子项 下面结合 CoordinatorLayout + AppBarLayout + CollapsingToolbarLayout 的例子来学习 简单使用按照惯例，我们先看一下效果图： 从效果图来看，就是一个可根据手势滑动进行折叠的 Toolbar，很普通但很实用，下面看看具体实现。对 Toolbar 还不熟悉的可以参考这篇介绍 MaterialDesign（一），ToolBar使用 引入 com.android.support:design由于我们这个例子使用到 CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout，所以需要引入 com.android.support:design 1compile &apos;com.android.support:design:26.1.0&apos; xml 文件创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;200dp&quot;&gt; &lt;!--添加 android:minHeight=&quot;?actionBarSize&quot; 解决 RecyclerView 最后一项显示不全--&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:minHeight=&quot;?attr/actionBarSize&quot; app:collapsedTitleTextAppearance=&quot;@style/CollapsedTitleTextStyle&quot; app:expandedTitleTextAppearance=&quot;@style/ExpandedTitleTextStyle&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/android_bg&quot;/&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:title=&quot;标题&quot;/&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!--以下这部分我们下篇文章再介绍，不是本篇的重点，暂时知道是一个列表就可以了--&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id=&quot;@+id/refresh_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;==================================================================&lt;!--CollapsingToolbarLayout展开时标题文字样式--&gt;&lt;style name=&quot;ExpandedTitleTextStyle&quot; parent=&quot;TextAppearance.AppCompat.Title&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;30sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;#333333&lt;/item&gt;&lt;/style&gt;&lt;!--CollapsingToolbarLayout折叠时标题文字样式--&gt;&lt;style name=&quot;CollapsedTitleTextStyle&quot; parent=&quot;TextAppearance.AppCompat.Title&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;16sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;#ffffff&lt;/item&gt;&lt;/style&gt; 从 xml 布局文件看，根布局是 CoordinatorLayout，里面包含了 AppBarLayout 和 SwipeRefreshLayout（下篇介绍），AppBarLayout 包含了 CollapsingToolbarLayout 作为可折叠的 Toolbar 的父布局。 AppBarLayout 的子项并没有硬性规定，可以包含任意视图。 这里我们重点关注 CollapsingToolbarLayout 的几个属性： app:layout_scrollFlags Scroll Flag 作用 scroll 子 View 伴随着滚动事件而滚出或滚进屏幕。如果要使用以下其他值，必须设置该值；如果在设置该值的子 View 之前的View 没有设置这个值，那么该 View 的设置将无效 enterAlways 快速返回模式。当 Scrolling View 向下滑动时，子 View 将直接向下滑动，而不管 Scrolling View 是否在滑动。使用该值必须与 scroll 一起使用才有效果 enterAlwaysCollapsed 该值是对 enterAlways 的补充，涉及到子 View 的高度和最小高度，向下滚动时，子 View 先向下滚动最小高度值，然后 Scrolling View 开始滚动，到达边界时，子 View 再向下滚动，至显示完全 exitUntilCollapsed 发生向上滚动事件时，子 View 向上滚动退出直至设置的最小高度，然后 Scrolling View 才开始滚动 snap 在滚动结束后，如果设置该属性的 view 只是部分可见，它将滑动到最近的边界，不会存在部分显示的情况 在本篇的例子中我们设置的是 app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed|snap&quot;，呈现的效果是往上滑时，直至 Toolbar 设置的高度时，才轮到下面列表的滑动；往下滑时，直至滑动到列表顶部时，才轮到 CollapsingToolbarLayout 的滑动，由于设置了 snap，所以不会存在 CollapsingToolbarLayout 显示部分的时候，要么显示最小高度，要么完全显示。其他效果这里就不一一展示了，感兴趣的可以自己实现，跑一下效果 app:collapsedTitleTextAppearance 用于设置折叠时标题文字样式，这里只是简单的设置了大小和颜色 app:expandedTitleTextAppearance 用于设置展开时标题文字样式，这里也只是简单的设置了大小和颜色 到此就完成了一开始展示的效果，是不是很简单，甚至不用在 Activity 中编写任何代码。 结语本文主要介绍了 CoordinatorLayout + AppBarLayout + CollapsingToolbarLayout 的使用，这种折叠式的布局在实际开发中还是用到的比较多。本文 demo 已上传到 github。下面是几个控件的官方API地址（自备梯子） CoordinatorLayout API AppBarLayout API CollapsingToolbarLayout API]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
        <tag>CoordinatorLayout</tag>
        <tag>AppBarLayout</tag>
        <tag>CollapsingToolbarLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign（二），DrawerLayout使用]]></title>
    <url>%2F2018%2F11%2F23%2FMaterialDesign%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%8CDrawerLayout%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是 DrawerLayout DrawerLayout（抽屉式导航栏）是一个面板，它将应用的主要导航选项显示在屏幕左边缘。大多数情况下，它处于隐藏状态，但是如果用户从屏幕左边缘滑动手指，同时在应用顶层触摸操作栏中的应用图标，它将会显示出来 简单来说这是一个实现了侧滑菜单效果的控件，主要分为侧边菜单和主内容两部分，并可根据手势操作进行展开或隐藏。下面结合 Toolbar + DrawerLayout + NavigationView 来学习一下 简单使用按照惯例，我们先看一下效果图： 从效果图来看，界面主要分为3部分：Toolbar、内容区域、侧边栏（NavigationView）。下面我们就该效果看看具体实现，如果对 Toolbar 不熟悉的，可以看我的前一篇文章 MaterialDesign（一），ToolBar使用 引入 com.android.support:design由于我们这个例子使用到 NavigationView，所以需要引入 com.android.support:design 1compile &apos;com.android.support:design:26.1.0&apos; xml 文件创建 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;false&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;!--此处可以添加自定义控件--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;custom&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:id=&quot;@+id/tv_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;内容&quot;/&gt; &lt;/FrameLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:fitsSystemWindows=&quot;true&quot; app:headerLayout=&quot;@layout/nav_header&quot; app:menu=&quot;@menu/menu_nav&quot;/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 从 xml 布局文件看，我们的根布局是 DrawerLayout，里面包含两个部分，从上到下第一部分必须是主布局，第二部分是侧边栏，这里的侧边栏我们使用了 NavigationView，也可以是任意视图。第二部分必须添加 android:layout_gravity 属性，这里使用了 android:layout_gravity=&quot;start&quot; 表示是左侧边栏。NavigationView 的其他属性，下面介绍 NavigationView 再进行解释，现在主要关注 DrawerLayout 的实现 Activity 中获取并设置相关属性值，以及事件监听123456789101112131415161718192021222324252627282930313233@BindView(R.id.drawer_layout)DrawerLayout mDrawerLayout;mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; // 点击导航图标展开侧边栏 mDrawerLayout.openDrawer(GravityCompat.START); &#125;&#125;);// 如有需要可以设置DrawerLayout监听mDrawerLayout.addDrawerListener(new DrawerLayout.DrawerListener() &#123; @Override public void onDrawerSlide(View drawerView, float slideOffset) &#123; // 滑动过程回调 &#125; @Override public void onDrawerOpened(View drawerView) &#123; // 展开回调 &#125; @Override public void onDrawerClosed(View drawerView) &#123; // 关闭回调 &#125; @Override public void onDrawerStateChanged(int newState) &#123; // 状态改变回调 &#125;&#125;); 可以看出在 Activity 中无需设置什么，主要设置一下 Toolbar 的导航图标点击时展开侧边栏，设置监听可根据具体业务设置 NavigationView 介绍 Represents a standard navigation menu for application. The menu contents can be populated by a menu resource file.NavigationView is typically placed inside a DrawerLayout. 大致的意思是 NavigationView 代表着应用的标准导航栏，菜单的内容可以由菜单资源文件填充，通常放置在 DrawerLayout 中 上面我们在 xml 中已经使用到 NavigationView 这个控件了，下面了解一下使用到的这两个属性， app:headerLayout=&quot;@layout/nav_header&quot; 属性是给导航栏设置一个头布局，可以引用 layout 文件； app:menu=&quot;@menu/menu_nav&quot; 属性是为导航栏设置菜单项，支持分组，根据效果图，看下具体的实现1234567891011121314nav_header.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/android_bg&quot;/&gt;&lt;/LinearLayout&gt; 1234567891011121314151617181920212223242526272829303132333435menu_nav.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:title=&quot;设置&quot;&gt; &lt;menu&gt; &lt;group android:id=&quot;@+id/setting_g_1&quot;&gt; &lt;item android:id=&quot;@+id/setting_item_1&quot; android:icon=&quot;@drawable/ic_settings_black_24dp&quot; android:title=&quot;设置1&quot;/&gt; &lt;item android:id=&quot;@+id/setting_item_2&quot; android:icon=&quot;@drawable/ic_settings_black_24dp&quot; android:title=&quot;设置2&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt; &lt;item android:title=&quot;设置（个性）&quot;&gt; &lt;menu&gt; &lt;group android:id=&quot;@+id/setting_g_2&quot;&gt; &lt;item android:id=&quot;@+id/setting_item_3&quot; android:icon=&quot;@drawable/ic_settings_black_24dp&quot; android:title=&quot;设置3&quot;/&gt; &lt;item android:id=&quot;@+id/setting_item_4&quot; android:icon=&quot;@drawable/ic_settings_black_24dp&quot; android:title=&quot;设置4&quot;/&gt; &lt;/group&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 这里简单的设置了一张图片作为头部，菜单项则使用了两个分组，每个分组里面有两个菜单项，可以说是非常简单。最后在 Activity 中设置各个菜单项的点击事件即可，代码如下12345678910111213141516171819202122232425mNavView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; int id = item.getItemId(); String tip = &quot;&quot;; switch (id) &#123; case R.id.setting_item_1: tip = &quot;设置1&quot;; break; case R.id.setting_item_2: tip = &quot;设置2&quot;; break; case R.id.setting_item_3: tip = &quot;设置3&quot;; break; case R.id.setting_item_4: tip = &quot;设置4&quot;; break; &#125; Toast.makeText(ToolbarActivity.this, tip, Toast.LENGTH_SHORT).show(); // 隐藏侧边栏 mDrawerLayout.closeDrawer(GravityCompat.START); return false; &#125;&#125;); 结语本文主要介绍了 DrawerLayout 和 NavigationView 的使用，DrawerLayout 在实际开发过程中用的也比较多。想了解更多，可以参考官方 API。DrawerLayout API，NavigationView API，请自备梯子。本文 demo 已上传到 github]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>MaterialDesign</tag>
        <tag>DrawerLayout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaterialDesign（一），ToolBar使用]]></title>
    <url>%2F2018%2F11%2F23%2FMaterialDesign%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%8CToolBar%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是 Toolbar A Toolbar is a generalization of action bars for use within application layouts. While an action bar is traditionally part of an Activity’s opaque window decor controlled by the framework, a Toolbar may be placed at any arbitrary level of nesting within a view hierarchy. An application may choose to designate a Toolbar as the action bar for an Activity using the setSupportActionBar() method. 以上是官方的介绍，简单来说 Toolbar 是在 Android 5.0 开始推出的一个 Material Design 风格的导航控件，Toolbar 可作为应用的导航控件，可以替代以前的 ActionBar。比 ActionBar 更佳灵活，不一定要固定在 Activity 的顶部，而是可以嵌套在任意位置。应用可以使用setSupportActionBar()方法将 Toolbar 设置为 Activity 的 ActionBar。 Toolbar 为我们提供了一些可定制的修改属性，根据API文档的介绍，主要有以下几类： 可设置导航栏图标 可设置 App 的 logo 可设置标题和子标题 可添加一个或多个的自定义控件 可添加 ActionMenu 简单使用按照惯例，我们先看一下效果图： 从效果图来看，从左到右分别是我们设置的 导航栏图标、App的logo、标题和副标题、自定义控件、ActionMenu。下面我们来看具体的代码实现。 引入v7包由于 Toolbar 是v7包的一个控件，首先需要引入该包 1implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; XML 添加 Toolbar 1234567891011121314&lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@color/colorPrimary&quot;&gt; &lt;!--此处可以添加自定义控件--&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;custom&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;16sp&quot;/&gt;&lt;/android.support.v7.widget.Toolbar&gt; 创建 menu_toolbar.xml 存放在 res/layout/menu 目录下，用于为 Toolbar 设置 ActionMenu 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;!--右侧搜索操作条目--&gt; &lt;item android:id=&quot;@+id/action_search&quot; android:icon=&quot;@drawable/ic_search_white_24dp&quot; android:title=&quot;搜索&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;!--右侧设置条目，收起--&gt; &lt;item android:id=&quot;@+id/action_setting&quot; android:title=&quot;设置&quot; app:showAsAction=&quot;never&quot;/&gt; &lt;item android:id=&quot;@+id/action_help&quot; android:title=&quot;帮助&quot; app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; 重点关注一下 app:showAsAction 属性，该属性有以下几种取值 always：使菜单项一直显示在 Toolbar 上 ifRoom：如果有足够的空间，这个值会使菜单项显示在 Toolbar 上 never：使菜单项永远都不出现在 Toolbar 上,在…的子项中显示 withText：使菜单项和它的图标，菜单文本一起显示 Activity 中获取并设置相关属性值，以及事件监听123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 隐藏系统默认的导航栏 supportRequestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_toolbar); ButterKnife.bind(this); initToolbar();&#125;private void initToolbar() &#123; // 设置ActionMenu布局（方式一） mToolbar.inflateMenu(R.menu.menu_toobar); // 设置logo mToolbar.setLogo(R.mipmap.ic_launcher_round); // 设置标题 mToolbar.setTitle(&quot;title&quot;); // 设置副标题 mToolbar.setSubtitle(&quot;sub title&quot;); // 设置标题的字体颜色 mToolbar.setTitleTextColor(getResources().getColor(android.R.color.white)); // 设置子标题的字体颜色 mToolbar.setSubtitleTextColor(getResources().getColor(android.R.color.white));// setSupportActionBar(mToolbar); // 设置导航按钮图标 mToolbar.setNavigationIcon(R.drawable.ic_menu_white_24dp); // 设置更多按钮图标 mToolbar.setOverflowIcon(getResources().getDrawable(R.drawable.ic_more_horiz_white_24dp)); // 设置导航图标的点击事件（方式一） mToolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; mDrawerLayout.openDrawer(GravityCompat.START); &#125; &#125;); // 设置各菜单的点击事件（方式一） mToolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; int id = item.getItemId(); String tip = &quot;&quot;; switch (id) &#123; case R.id.action_search: tip = &quot;搜索&quot;; break; case R.id.action_setting: tip = &quot;设置&quot;; break; case R.id.action_help: tip = &quot;帮助&quot;; break; &#125; Toast.makeText(ToolbarActivity.this, tip, Toast.LENGTH_SHORT).show(); return false; &#125; &#125;);&#125; 设置 ActionMenu 和设置 点击事件以上是第一种方式，还可以使用以下方式，效果一样1234567891011121314151617181920212223242526272829@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; // 设置ActionMenu布局（方式二） getMenuInflater().inflate(R.menu.menu_toobar, menu); return true;&#125;@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; int id = item.getItemId(); String tip = &quot;&quot;; switch (id) &#123; // 对应 NavigationIcon 的点击 case android.R.id.home: tip = &quot;菜单&quot;; break; case R.id.action_search: tip = &quot;搜索&quot;; break; case R.id.action_setting: tip = &quot;设置&quot;; break; case R.id.action_help: tip = &quot;帮助&quot;; break; &#125; Toast.makeText(ToolbarActivity.this, tip, Toast.LENGTH_SHORT).show(); return false;&#125; 重写 Activity 的 onCreateOptionsMenu 和 onOptionsItemSelected 方法即可 到此已经实现了一开始所看到的效果 使用中的一些坑 ActionMenu 无法显示如果我们在代码中调用了 setSupportActionBar 方法设置了 Toolbar，此时如果使用第一种方式（mToolbar.inflateMenu(R.menu.menu_toobar)）创建 ActionMenu 则会导致无法显示，需使用第二种方式（重新 onCreateOptionsMenu）来创建 ActionMenu 才可以 mToolbar.setTitle 不生效如果先调用了 setSupportActionBar 方法后，再调用 mToolbar.setTitle(&quot;title&quot;) 来设置 title 的话会导致无法生效，需先调用 mToolbar.setTitle(&quot;title&quot;) 再调用 setSupportActionBar 才能生效 NavigationIcon 与右侧内容间距太大这个问题应该挺多人遇到过，其实可以通过在 xml 给 Toolbar 设置 app:contentInsetStartWithNavigation=&quot;0dp&quot; 或在代码中使用 setContentInsetStartWithNavigation(int) 方法进行设置，来控制NavigationIcon 与右侧内容的间距 结语本文只是简单地介绍了 Toolbar 和其使用，虽然该控件已经很完善了，不过实际开发中还是为自定义导航栏为主，主要方便扩展，想了解 Toolbar 的更多介绍以及相关 API 请参考官方文档(需要梯子)，本文 demo 已上传到 github]]></content>
      <categories>
        <category>MaterialDesign</category>
      </categories>
      <tags>
        <tag>ToolBar</tag>
        <tag>MaterialDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android布局优化]]></title>
    <url>%2F2018%2F11%2F23%2FAndroid%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[本文主要记录Android布局优化的一些小技巧Android中，如果一个View树的高度太高，就会严重影响测量，布局和绘制的速度，因此可以使用一些方法来降低View树的高度，提高用户体验 避免使用过多嵌套先来看一个非常常见的效果 相信这样的效果对我们来说完全不是问题，然而很多人会这样写布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:padding=&quot;5dp&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;第一项&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:src=&quot;@drawable/arrows_right&quot; /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#cccccc&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; android:padding=&quot;5dp&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;TextView android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_weight=&quot;1&quot; android:text=&quot;第二项&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:src=&quot;@drawable/arrows_right&quot; /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 可以看到这里布局嵌套了多层，类似这种效果有更优雅的写法，效果是完全一样的1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;@drawable/spacer&quot; android:orientation=&quot;vertical&quot; android:showDividers=&quot;middle&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:drawableLeft=&quot;@mipmap/ic_launcher&quot; android:drawablePadding=&quot;10dp&quot; android:drawableRight=&quot;@drawable/arrows_right&quot; android:gravity=&quot;center_vertical&quot; android:padding=&quot;5dp&quot; android:text=&quot;第一项&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:drawableLeft=&quot;@mipmap/ic_launcher&quot; android:drawablePadding=&quot;10dp&quot; android:drawableRight=&quot;@drawable/arrows_right&quot; android:gravity=&quot;center_vertical&quot; android:padding=&quot;5dp&quot; android:text=&quot;第二项&quot; android:textSize=&quot;18sp&quot; /&gt;&lt;/LinearLayout&gt; 这里主要用到了LinearLayout的android:divider=&quot;@drawable/spacer&quot; 和android:showDividers=&quot;middle&quot;两个属性添加分割线，注意android:divider里面的参数必须是shape类型才能显示。TextView里面则用到了android:drawableLeft=&quot;@mipmap/ic_launcher&quot;设置文字左边图片，android:drawableRight=&quot;@drawable/arrows_right&quot;同理这是文字右边图片，android:drawablePadding=&quot;10dp&quot;设置图片与文字的间距。我们可以对比一下两个布局文件，更少的嵌套，更简洁的代码，相信你会更喜欢第二种写法。 重用布局文件 include、mergeinclude 标签简单来说&lt;include&gt;标签就是为了一些通用的UI来使用的，有时候我们不想用系统的Toolbar，完全可以自己写一个满足我们的需求，先看效果。 这里很简单的实现了左边一个图片，中间标题，右边一个图片，一般情况左边是一个back按钮，右边一个action按钮，这里为了方便演示就直接用系统里的图片。关键代码片段如下。1234567891011121314151617181920212223242526272829303132&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;@drawable/spacer&quot; android:orientation=&quot;vertical&quot; android:showDividers=&quot;middle&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:padding=&quot;5dp&quot;&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;标题&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;ImageView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:src=&quot;@mipmap/ic_launcher&quot; /&gt; &lt;/RelativeLayout&gt; ...&lt;/LinearLayout&gt; 由于我们会在多个Activity使用到这个布局，你完全可以每个Activity都拷贝一份上面的代码，但我相信身为程序猿的你不会那么做，因为如果某一天需求需要改动这个布局，而你每个Activity都需要修改，这时候你是崩溃的。为解决此问题我们就可以用到&lt;include&gt;标签来重用此UI。首先我们可以新建一个top_view.xml布局文件，代码就是把上面包含的整个提取出来。然后把刚刚的布局替换成&lt;include&gt;。12345678910&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:divider=&quot;@drawable/spacer&quot; android:orientation=&quot;vertical&quot; android:showDividers=&quot;middle&quot;&gt; &lt;include layout=&quot;@layout/top_view&quot; /&gt; ...&lt;/LinearLayout&gt; 使用layout=&quot;@layout/top_view&quot;属性将我们刚刚的布局引入即可。非常简便，这样即使需要改动我们只需修改top_view.xml里面的内容就能适用整个APP。 merge 标签简单来说&lt;merge&gt;标签可以有效的减少多余的布局嵌套，这里简单的举个栗子。直接贴关键代码1234567&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;include layout=&quot;@layout/ok_cancel_layouy&quot; /&gt; &lt;/LinearLayout&gt; ok_cancel_layouy.xml123456789101112131415&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;ok&quot; /&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;cancel&quot; /&gt;&lt;/LinearLayout&gt; 这时候我们看下View的层次，抛开最外层的FrameLayout不说，先是LinearLayout接着是&lt;include&gt;里面的LinearLayout，最后是两个Button，这时候内层的LinearLayout其实是多余的，我们可以使用&lt;merge&gt;来代替，这样系统就会忽略&lt;merge&gt;直接放下两个Button。修改后的ok_cancel_layouy.xml123456789101112&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;ok&quot; /&gt; &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;cancel&quot; /&gt;&lt;/merge&gt; View延时加载上面我们知道了通过&lt;include&gt;可以引用通用UI，还可以使用&lt;ViewStub&gt;来引用并实现延迟加载。&lt;ViewStub&gt;是一个非常轻量级的控件，它没有大小，没有绘制，也不参与布局。填写资料的时候，有时会有更多资料填写，这时候我们需要实现点击更多才显示其他资料，效果如下 点击more的时候会多出两个输入框 布局文件如下123456789101112131415161718192021222324&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;EditText android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:hint=&quot;name&quot; /&gt; &lt;ViewStub android:id=&quot;@+id/view_stub&quot; android:layout_width=&quot;match_parent&quot; android:layout=&quot;@layout/more_layout&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;Button android:id=&quot;@+id/btn_more&quot; android:layout_width=&quot;wrap_content&quot; android:text=&quot;more&quot; android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt; more_layout.xml1234567891011121314151617181920&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;EditText android:id=&quot;@+id/et_more1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:hint=&quot;more1&quot; /&gt; &lt;EditText android:id=&quot;@+id/et_more2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:hint=&quot;more2&quot; /&gt;&lt;/LinearLayout&gt; 点击more进行显示12345678910111213btn_more = (Button) findViewById(R.id.btn_more);btn_more.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; ViewStub viewStub = (ViewStub) findViewById(R.id.view_stub); 1.viewStub.setVisibility(View.VISIBLE); if (viewStub != null) &#123; 2.View inflatedView = viewStub.inflate(); et_more1 = (EditText) inflatedView.findViewById(R.id.et_more1); et_more2 = (EditText) inflatedView.findViewById(R.id.et_more2); &#125; &#125;&#125;); 有两种方法可以让&lt;ViewStub&gt;的布局进行显示，一种是直接设置viewStub.setVisibility(View.VISIBLE)，第二种则是使用inflate来加载，如要获取到里面控件，我们一般采用第二种方法。从上面可以看出&lt;ViewStub&gt;的用法类似于&lt;include&gt;，不同的是&lt;ViewStub&gt;必须指定layout_width和layout_height属性，还有一点需要注意&lt;ViewStub&gt;所加载的布局是不可以使用&lt;merge&gt;标签的。 对于Android布局优化就写这些，另外系统还提供了一个工具HierarchyView可以帮助我们更好的优化布局，需要学习更多的可以直接阅读官网的文章。(需要科学上网)]]></content>
      <categories>
        <category>Android性能优化</category>
      </categories>
      <tags>
        <tag>布局优化</tag>
      </tags>
  </entry>
</search>
